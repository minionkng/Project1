Этот код реализует Telegram-бота для игры в рулетку, позволяя пользователям делать ставки и проверять выиграли ли они. Бот работает на основе библиотеки telebot, генерируя случайные результаты для каждой ставки и отслеживая баланс и оставшиеся раунды у каждого игрока.

Подробный разбор кода

1)Инициализация и импорт библиотек

import random

import telebot

Модуль random используется для генерации случайных чисел, имитируя случайный результат рулетки. telebot — это библиотека для работы с Telegram API.

2)Создание экземпляра бота

TOKEN = "7634526553:AAGovS-r-DlJ2jeuHKeZCwFJJ5Zo-70cOxk"

bot = telebot.TeleBot(TOKEN)

Здесь создаётся объект TeleBot с уникальным токеном, который позволяет боту взаимодействовать с Telegram.

3)Хранение пользовательских данных


user_data = {}

user_data хранит информацию о каждом пользователе, которая включает его баланс, ставку, выбор (чётное/нечётное), и количество оставшихся раундов. Данные сохраняются по уникальному chat_id.

4)Команда /start



@bot.message_handler(commands=['start'])

def start_game(message):

    chat_id = message.chat.id

    user_data[chat_id] = {'balance': 100, 'rounds': 10}

    bot.send_message(chat_id, "Добро пожаловать в игру Рулетка! Ваш стартовый баланс: 100.\nВведите ставку для начала игры.")

При получении команды /start, бот:


Создаёт начальную запись в user_data для пользователя с балансом 100 и 10 раундами.

Отправляет приветственное сообщение и приглашает пользователя сделать ставку.

5)Обработка ставки



@bot.message_handler(func=lambda message: message.chat.id in user_data and user_data[message.chat.id]['rounds'] > 0)

def place_bet(message):

Этот обработчик срабатывает, если пользователь активен в user_data и у него остались раунды. Бот:


Пытается прочитать ставку пользователя, преобразуя введённый текст в int.

Если ставка больше баланса, выводит сообщение об ошибке.

Если ставка допустима, сохраняет её и переходит к следующему этапу — запросу выбора чётного/нечётного.

6)Выбор чётного/нечётного



def place_choice(message):

    chat_id = message.chat.id

    choice = message.text.strip().lower()
  ...

В этой функции бот проверяет выбор пользователя:


Если пользователь вводит не «чётное» или «нечётное», бот просит повторить ввод.

Сохраняет выбор пользователя и запускает функцию play_round() для проведения раунда игры.

7)Игровая логика — play_round


def play_round(chat_id):

    bet_amount = user_data[chat_id]['bet_amount']

    choice = user_data[chat_id]['choice']
  
    balance = user_data[chat_id]['balance']
    ...

Здесь происходит:


Генерация случайного числа от 0 до 36. Если выпадает 0, пользователь проигрывает.

Проверка результата:

Если результат — чётное число и пользователь выбрал «чётное», или наоборот, пользователь выигрывает, и ставка добавляется к балансу.

В противном случае пользователь теряет ставку.

Обновление данных: баланс и оставшиеся раунды уменьшаются в зависимости от результата.

8)Проверка окончания игры


if balance <= 0:
  
    bot.send_message(chat_id, "У вас закончились деньги! Игра окончена.")
 
    del user_data[chat_id]

elif user_data[chat_id]['rounds'] <= 0:

    bot.send_message(chat_id, "Игра окончена. Режим раундов завершён.")
  
    del user_data[chat_id]
else:

    bot.send_message(chat_id, f"Ваш текущий баланс: {balance}. Введите ставку для следующего раунда.")

Бот проверяет, закончились ли у пользователя деньги или раунды. Если баланс меньше или равен нулю, или закончились раунды:


Выводится сообщение о завершении игры, и данные пользователя удаляются.

Иначе бот просит ввести ставку для следующего раунда.

9)Запуск бота


bot.polling()

Метод bot.polling() запускает бесконечный цикл, обрабатывающий входящие сообщения, чтобы бот оставался активным и доступным для пользователей.

Итог

Этот бот воссоздаёт простую игру в рулетку, предоставляя пользователю интерфейс для ставок, проверки баланса и определения выигрыша или проигрыша, отслеживая результаты и завершая игру, когда деньги или раунды заканчиваются.
